<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ガチャ!!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #fff0f3;
        }

        .gacha-fullscreen {
            width: 100%;
            height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #gacha-canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -webkit-image-rendering: pixelated;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <div class="gacha-fullscreen" id="gacha-fullscreen">
        <canvas id="gacha-canvas" width="500" height="500"></canvas>
    </div>

    <script>
    // ===== GACHA MACHINE — Standalone =====

    // Positions ordered geographically: right → center → left
    var GACHA_POSITIONS = ['back', 'front', 'mid'];
    var GACHA_ROUTE_MAP = { back: 'a', front: 'a', mid: 'b' };

    var BG_COLOR = '#fff0f3';

    var gachaState = {
        canvas: null,
        ctx: null,
        canvasScale: 1,
        position: 0,        // 0=back(right), 1=mid(left), 2=front(center)
        phase: 'idle',
        blinkState: false,
        blinkTimer: 0,
        joystickDir: null,
        joystickTimer: 0,
        buttonPressed: false,
        buttonTimer: 0,
        clawY: 0,
        grabY: 0,
        clawSlideX: 0,      // current animated X offset (smooth lateral movement)
        clawTargetX: 0,     // target X offset (from CLAW_OFFSETS)
        showGrab: false,
        hiddenPlush: null,
        // Drop animation state
        dropping: false,     // true while plush is falling (active animation)
        dropPlush: null,     // which plush key is dropping (e.g. 'inside4')
        dropX: 0,            // drop plush X position
        dropY: 0,            // drop plush Y position (animated)
        dropRotation: 0,     // rotation in radians (for fail drop)
        dropIsFail: false,   // true if current drop is a fail (stays in same layer)
        // Persisted fallen plushies from previous fails: { key, x, y, rotation }
        fallenPlushies: [],
        lastTime: 0,
        images: {},
        loaded: false,
        clickBound: false,
        animFrame: null
    };

    // Layer definitions with exact Pixaki coordinates
    var GACHA_LAYERS = {
        bg:              { src: 'bg.png',              x: 0,   y: 0,   w: 500, h: 500 },
        inside1:         { src: 'inside-1.png',        x: 211, y: 138, w: 78,  h: 82  },
        inside2:         { src: 'inside-2.png',        x: 199, y: 220, w: 82,  h: 48  },
        inside3:         { src: 'inside-3.png',        x: 157, y: 190, w: 74,  h: 76  },
        inside4:         { src: 'inside-4.png',        x: 258, y: 181, w: 74,  h: 76  },
        inside5:         { src: 'inside-5.png',        x: 163, y: 168, w: 82,  h: 78  },
        inside6:         { src: 'inside-6.png',        x: 298, y: 195, w: 47,  h: 74  },
        inside7:         { src: 'inside-7.png',        x: 155, y: 185, w: 59,  h: 82  },
        clawOpen:        { src: 'claw-open.png',       x: 275, y: 74,  w: 45,  h: 38  },
        clawHolder:      { src: 'claw-holder.png',     x: 289, y: 54,  w: 17,  h: 8   },
        clawBarShort:    { src: 'claw-bar-short.png',  x: 295, y: 55,  w: 5,   h: 29  },
        grabBackPlush:   { src: 'claw-back-plush.png',   x: 258, y: 101, w: 74, h: 76 },
        grabBackBar:     { src: 'claw-back-bar.png',      x: 295, y: 54,  w: 5,  h: 27 },
        grabBackFingers: { src: 'claw-back-fingers.png',  x: 275, y: 74,  w: 45, h: 40 },
        grabBackHolder:  { src: 'claw-back-holder.png',   x: 289, y: 54,  w: 17, h: 8  },
        grabMidPlush:    { src: 'claw-mid-plush.png',     x: 156, y: 101, w: 74, h: 76 },
        grabMidBar:      { src: 'claw-mid-bar.png',       x: 193, y: 54,  w: 5,  h: 27 },
        grabMidFingers:  { src: 'claw-mid-fingers.png',   x: 173, y: 74,  w: 45, h: 40 },
        grabMidHolder:   { src: 'claw-mid-holder.png',    x: 187, y: 54,  w: 17, h: 8  },
        grabFrontPlush:  { src: 'claw-front-plush.png',   x: 211, y: 94,  w: 78, h: 82 },
        grabFrontBar:    { src: 'claw-front-bar.png',     x: 248, y: 54,  w: 5,  h: 27 },
        grabFrontFingers:{ src: 'claw-front-fingers.png', x: 228, y: 74,  w: 45, h: 40 },
        grabFrontHolder: { src: 'claw-front-holder.png',  x: 242, y: 54,  w: 17, h: 8  },
        glass:           { src: 'glass.png',           x: 154, y: 38,  w: 192, h: 231 },
        glassShine:      { src: 'glass-shine.png',     x: 155, y: 82,  w: 190, h: 149 },
        machine:         { src: 'machine.png',         x: 123, y: 3,   w: 254, h: 487 },
        dither:          { src: 'dither.png',          x: 129, y: 12,  w: 241, h: 465 },
        gacha1off:       { src: 'gacha1-off.png',      x: 160, y: 387, w: 119, h: 32  },
        gacha1on:        { src: 'gacha1-on.png',       x: 160, y: 387, w: 119, h: 32  },
        gacha2off:       { src: 'gacha2-off.png',      x: 160, y: 420, w: 119, h: 32  },
        gacha2on:        { src: 'gacha2-on.png',       x: 160, y: 420, w: 119, h: 32  },
        btnStandby:      { src: 'btn-standby.png',     x: 306, y: 306, w: 20,  h: 16  },
        btnPressed:      { src: 'btn-pressed.png',     x: 306, y: 309, w: 20,  h: 13  },
        joyUpStick:      { src: 'joy-up-stick.png',    x: 246, y: 285, w: 6,   h: 30  },
        joyUpBase:       { src: 'joy-up-base.png',     x: 237, y: 262, w: 24,  h: 24  },
        joyRightStick:   { src: 'joy-right-stick.png', x: 246, y: 289, w: 25,  h: 26  },
        joyRightBase:    { src: 'joy-right-base.png',  x: 265, y: 271, w: 24,  h: 24  },
        joyLeftStick:    { src: 'joy-left-stick.png',  x: 225, y: 289, w: 25,  h: 26  },
        joyLeftBase:     { src: 'joy-left-base.png',   x: 207, y: 271, w: 24,  h: 24  }
    };

    // Which inside plush corresponds to each grab position
    // back (RIGHT) = inside4, mid (LEFT) = inside3, front (CENTER) = inside1
    var GRAB_HIDES = { back: 'inside4', mid: 'inside3', front: 'inside1' };

    // Claw X offsets: back=0 (right), mid=-102 (left), front=-47 (center)
    var CLAW_OFFSETS = { back: 0, mid: -102, front: -47 };

    // Y position where the plush top sits when grabbed (just below fingers grip)
    var GRAB_PLUSH_Y = 100;

    // Descend distances per position
    // inside4 at y:181, inside3 at y:190, inside1 at y:138
    // Claw open bottom ~y:112. Distance = plush_y - 112
    var DESCEND_PIXELS = {
        back: 75,    // inside4 at y:181 → 181-112 = 69, round up a bit
        mid: 82,     // inside3 at y:190 → 190-112 = 78, round up a bit
        front: 35    // inside1 at y:138 → 138-112 = 26, round up a bit
    };
    var DESCEND_DURATION = 2000;  // ms — slow, like a real claw machine
    var GRAB_PAUSE = 600;         // pause at bottom before closing — dramatic
    var ASCEND_DURATION = 2500;   // ms — even slower on the way up with weight
    var ASCEND_TARGET = 0;        // return to original sprite positions (plush stays inside glass)
    var SLIDE_TO_DROP_DURATION = 800;  // ms — slide claw back to right position before dropping
    var DROP_PAUSE = 300;              // pause before opening claw
    var DROP_DURATION = 600;           // ms — plush falls with gravity
    var DROP_DISTANCE = 200;           // px — how far the plush falls before disappearing
    var FADEOUT_DELAY = 600;

    // Fail mechanic — claw drops plush mid-ascend
    var FAIL_CHANCE = 0.35;            // 35% chance of failing
    var FAIL_ASCEND_FRACTION = 0.45;   // ascend only 45% of the way before failing
    var FAIL_DROP_DURATION = 800;      // ms — longer fall with bounce
    var FAIL_ROTATION = Math.PI / 4;   // 45° clockwise rotation during fall
    // Glass clipping rect for the drop animation (plush disappears at glass edge)
    var GLASS_CLIP = { x: 154, y: 38, w: 192, h: 231 };

    var GACHA_HIT_AREAS = {
        joyLeft:  { x: 155, y: 235, w: 95, h: 95 },
        joyRight: { x: 245, y: 235, w: 60, h: 95 },
        button:   { x: 295, y: 295, w: 45, h: 45 }
    };

    // ===== IMAGE LOADING =====

    function loadGachaImages(callback) {
        if (gachaState.loaded) { callback(); return; }
        var keys = Object.keys(GACHA_LAYERS);
        var loaded = 0;
        var total = keys.length;
        var called = false;
        function done() {
            if (called) return;
            called = true;
            gachaState.loaded = true;
            callback();
        }
        for (var i = 0; i < keys.length; i++) {
            (function(key) {
                var img = new Image();
                img.onload = function () {
                    gachaState.images[key] = img;
                    loaded++;
                    if (loaded === total) done();
                };
                img.onerror = function () {
                    loaded++;
                    if (loaded === total) done();
                };
                img.src = 'img/gacha/' + GACHA_LAYERS[key].src;
            })(keys[i]);
        }
    }

    // ===== DRAWING =====

    function drawLayer(ctx, key, offsetX, offsetY) {
        var img = gachaState.images[key];
        var L = GACHA_LAYERS[key];
        if (!img) return;
        ctx.drawImage(img, L.x + (offsetX || 0), L.y + (offsetY || 0), L.w, L.h);
    }

    // Draw a bar sprite stretched vertically. The bar top stays at its original Y,
    // but its height grows by offsetY pixels (the claw descent/ascent distance).
    function drawBarStretched(ctx, barKey, offsetX, offsetY) {
        var img = gachaState.images[barKey];
        var L = GACHA_LAYERS[barKey];
        if (!img) return;
        var stretchedH = L.h + (offsetY || 0);
        if (stretchedH < 1) stretchedH = 1;
        ctx.drawImage(img,
            0, 0, img.naturalWidth, img.naturalHeight,
            L.x + (offsetX || 0), L.y, L.w, stretchedH
        );
    }

    function renderGacha() {
        var ctx = gachaState.ctx;
        if (!ctx || !gachaState.loaded) return;

        ctx.clearRect(0, 0, 500, 500);

        // 1. Background
        drawLayer(ctx, 'bg');

        // 2. Machine frame + dither (drawn early so plushies appear in front of interior lines)
        drawLayer(ctx, 'machine');
        drawLayer(ctx, 'dither');

        // Helper: draw a plush with rotation, clipped to glass
        function drawDroppedPlush(key, x, y, rotation) {
            var img = gachaState.images[key];
            var L = GACHA_LAYERS[key];
            if (!img) return;
            ctx.save();
            ctx.beginPath();
            ctx.rect(GLASS_CLIP.x, GLASS_CLIP.y, GLASS_CLIP.w, GLASS_CLIP.h);
            ctx.clip();
            if (rotation !== 0) {
                var cx = x + L.w / 2;
                var cy = y + L.h / 2;
                ctx.translate(cx, cy);
                ctx.rotate(rotation);
                ctx.drawImage(img, -L.w / 2, -L.h / 2, L.w, L.h);
            } else {
                ctx.drawImage(img, x, y, L.w, L.h);
            }
            ctx.restore();
        }

        // 3a. Success drop: plush falls BEHIND all other plushies, clipped to glass
        if (gachaState.dropping && !gachaState.dropIsFail && gachaState.dropPlush) {
            drawDroppedPlush(gachaState.dropPlush, gachaState.dropX, gachaState.dropY, 0);
        }

        // 3b. Inside plushies — draw back-to-front (7=back first, 1=front last)
        //     For each plush: if hidden by claw, skip. If it has a fallen version, draw that instead.
        //     If it's the active dropping plush (fail), draw at animated position in its layer.
        var plushOrder = ['inside7', 'inside6', 'inside5', 'inside4', 'inside3', 'inside2', 'inside1'];
        for (var i = 0; i < plushOrder.length; i++) {
            var pk = plushOrder[i];
            // Skip if claw is holding this plush
            if (pk === gachaState.hiddenPlush) continue;

            // Check if this is the actively dropping plush (fail animation in progress)
            if (gachaState.dropping && gachaState.dropIsFail && gachaState.dropPlush === pk) {
                drawDroppedPlush(pk, gachaState.dropX, gachaState.dropY, gachaState.dropRotation);
                continue;
            }

            // Check if this plush has a persisted fallen state from a previous fail
            var fallen = null;
            for (var f = 0; f < gachaState.fallenPlushies.length; f++) {
                if (gachaState.fallenPlushies[f].key === pk) { fallen = gachaState.fallenPlushies[f]; break; }
            }
            if (fallen) {
                drawDroppedPlush(pk, fallen.x, fallen.y, fallen.rotation);
                continue;
            }

            // Normal plush
            drawLayer(ctx, pk);
        }

        // 4. Claw system — in front of plushies, behind glass
        //    Holder NEVER moves vertically, bar STRETCHES, fingers/plush move
        var posName = GACHA_POSITIONS[gachaState.position];
        var clawOffX = gachaState.clawSlideX; // smooth animated X
        var clawOffY = gachaState.clawY;

        if (!gachaState.showGrab) {
            // Open claw — holder fixed, bar stretches down, fingers descend
            drawLayer(ctx, 'clawHolder', clawOffX, 0);
            drawBarStretched(ctx, 'clawBarShort', clawOffX, clawOffY);
            drawLayer(ctx, 'clawOpen', clawOffX, clawOffY);
        } else {
            // Closed claw with ORIGINAL plush sprite
            // Use "back" grab sprites as base, offset by CLAW_OFFSETS (same as open claw)
            var grabOffY = gachaState.grabY;
            var plushKey = gachaState.hiddenPlush; // e.g. 'inside4'
            drawLayer(ctx, 'grabBackHolder', clawOffX, 0);
            drawBarStretched(ctx, 'clawBarShort', clawOffX, grabOffY);
            // Draw the original inside plush sprite centered under the claw
            if (plushKey) {
                var plushImg = gachaState.images[plushKey];
                var plushL = GACHA_LAYERS[plushKey];
                if (plushImg) {
                    // Center the plush under the fingers
                    // Fingers center X = 275 + 45/2 + clawOffX = 297.5 + clawOffX
                    var fingersCenterX = 297 + clawOffX;
                    var px = fingersCenterX - plushL.w / 2;
                    var py = GRAB_PLUSH_Y + grabOffY;
                    ctx.drawImage(plushImg, px, py, plushL.w, plushL.h);
                }
            }
            drawLayer(ctx, 'grabBackFingers', clawOffX, grabOffY);
        }

        // 5. Glass — subtle reflection, always in front of everything inside the machine
        ctx.save();
        ctx.globalAlpha = 0.10;
        drawLayer(ctx, 'glass');
        ctx.restore();

        // Glass shine — subtle white reflection
        ctx.save();
        ctx.globalAlpha = 0.50;
        drawLayer(ctx, 'glassShine');
        ctx.restore();

        // 6. Letters (blink)
        if (gachaState.blinkState) {
            drawLayer(ctx, 'gacha1on');
            drawLayer(ctx, 'gacha2off');
        } else {
            drawLayer(ctx, 'gacha1off');
            drawLayer(ctx, 'gacha2on');
        }

        // 7. Button
        if (gachaState.buttonPressed) {
            drawLayer(ctx, 'btnPressed');
        } else {
            drawLayer(ctx, 'btnStandby');
        }

        // 8. Joystick
        if (gachaState.joystickDir === 'left') {
            drawLayer(ctx, 'joyLeftStick');
            drawLayer(ctx, 'joyLeftBase');
        } else if (gachaState.joystickDir === 'right') {
            drawLayer(ctx, 'joyRightStick');
            drawLayer(ctx, 'joyRightBase');
        } else {
            drawLayer(ctx, 'joyUpStick');
            drawLayer(ctx, 'joyUpBase');
        }
    }

    // ===== ANIMATION LOOP =====

    function gachaAnimLoop(time) {
        if (gachaState.phase === 'done') return;

        var dt = time - gachaState.lastTime;
        gachaState.lastTime = time;

        // Blink timer
        gachaState.blinkTimer += dt;
        if (gachaState.blinkTimer >= 500) {
            gachaState.blinkTimer -= 500;
            gachaState.blinkState = !gachaState.blinkState;
        }

        // Joystick tilt timer
        if (gachaState.joystickDir !== null) {
            gachaState.joystickTimer -= dt;
            if (gachaState.joystickTimer <= 0) {
                gachaState.joystickDir = null;
                if (gachaState.phase === 'joystickTilt') {
                    gachaState.phase = 'idle';
                }
            }
        }

        // Button timer
        if (gachaState.buttonPressed) {
            gachaState.buttonTimer -= dt;
            if (gachaState.buttonTimer <= 0) {
                gachaState.buttonPressed = false;
            }
        }

        // Smooth lateral claw slide (lerp toward target)
        var slideSpeed = 0.004; // lower = slower slide
        var diff = gachaState.clawTargetX - gachaState.clawSlideX;
        if (Math.abs(diff) > 0.5) {
            gachaState.clawSlideX += diff * Math.min(slideSpeed * dt, 1);
        } else {
            gachaState.clawSlideX = gachaState.clawTargetX;
        }

        renderGacha();
        gachaState.animFrame = requestAnimationFrame(gachaAnimLoop);
    }

    // ===== INTERACTION =====

    function hitTest(px, py, area) {
        return px >= area.x && px <= area.x + area.w &&
               py >= area.y && py <= area.y + area.h;
    }

    function moveJoystick(direction) {
        if (gachaState.phase !== 'idle' && gachaState.phase !== 'joystickTilt') return;

        if (direction === 'left' && gachaState.position < 2) {
            gachaState.position++;
        } else if (direction === 'right' && gachaState.position > 0) {
            gachaState.position--;
        } else {
            return;
        }

        gachaState.phase = 'joystickTilt';
        gachaState.joystickDir = direction;
        gachaState.joystickTimer = 400;
        // Set target X for smooth slide
        var newPosName = GACHA_POSITIONS[gachaState.position];
        gachaState.clawTargetX = CLAW_OFFSETS[newPosName];
    }

    function pressButton() {
        if (gachaState.phase !== 'idle' && gachaState.phase !== 'joystickTilt') return;
        // Snap claw to final position before grabbing
        var posName = GACHA_POSITIONS[gachaState.position];
        gachaState.clawSlideX = CLAW_OFFSETS[posName];
        gachaState.clawTargetX = gachaState.clawSlideX;
        gachaState.phase = 'grabbing';
        gachaState.buttonPressed = true;
        gachaState.buttonTimer = 200;
        grabSequence();
    }

    // Bounce easing: falls, bounces once, settles
    function easeOutBounce(t) {
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        } else if (t < 2 / 2.75) {
            t -= 1.5 / 2.75;
            return 7.5625 * t * t + 0.75;
        } else if (t < 2.5 / 2.75) {
            t -= 2.25 / 2.75;
            return 7.5625 * t * t + 0.9375;
        } else {
            t -= 2.625 / 2.75;
            return 7.5625 * t * t + 0.984375;
        }
    }

    // Helper: start the success drop animation
    function startSuccessDrop(routeKey, plushKey) {
        gachaState.phase = 'dropping';
        var plushL = GACHA_LAYERS[plushKey];
        if (!plushL) { console.error('startSuccessDrop: invalid plushKey', plushKey); return; }
        var fingersCenterX = 297 + gachaState.clawSlideX;
        gachaState.dropPlush = plushKey;
        gachaState.dropX = fingersCenterX - plushL.w / 2;
        gachaState.dropY = GRAB_PLUSH_Y;
        gachaState.dropRotation = 0;
        gachaState.dropIsFail = false;
        gachaState.dropping = true;
        gachaState.showGrab = false;
        gachaState.clawY = 0;

        var dropStart = performance.now();
        var dropStartY = gachaState.dropY;

        function animateDrop() {
            var elapsed = performance.now() - dropStart;
            var t = Math.min(elapsed / DROP_DURATION, 1);
            t = t * t; // ease-in (gravity)
            gachaState.dropY = dropStartY + DROP_DISTANCE * t;
            if (elapsed < DROP_DURATION) {
                requestAnimationFrame(animateDrop);
            } else {
                gachaState.dropping = false;
                gachaState.dropPlush = null;
                gachaState.phase = 'complete';
                setTimeout(function () {
                    gachaState.phase = 'done';
                    console.log('Gacha complete! Route:', routeKey);
                }, FADEOUT_DELAY);
            }
        }
        requestAnimationFrame(animateDrop);
    }

    function grabSequence() {
        var posName = GACHA_POSITIONS[gachaState.position];
        var routeKey = GACHA_ROUTE_MAP[posName];
        var descendPixels = DESCEND_PIXELS[posName];
        var willFail = Math.random() < FAIL_CHANCE;

        // Step 1: Descend open claw
        gachaState.phase = 'descending';
        var descendStart = performance.now();

        function animateDescend() {
            var elapsed = performance.now() - descendStart;
            var t = Math.min(elapsed / DESCEND_DURATION, 1);
            t = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            gachaState.clawY = descendPixels * t;

            if (elapsed < DESCEND_DURATION) {
                requestAnimationFrame(animateDescend);
            } else {
                gachaState.clawY = descendPixels;

                // Step 2: Pause at bottom, then close claw
                setTimeout(function () {
                    gachaState.hiddenPlush = GRAB_HIDES[posName];
                    // Remove from fallenPlushies if it was there (re-grabbing a failed plush)
                    gachaState.fallenPlushies = gachaState.fallenPlushies.filter(function (f) {
                        return f.key !== gachaState.hiddenPlush;
                    });
                    gachaState.showGrab = true;
                    gachaState.clawY = 0;
                    gachaState.grabY = descendPixels;
                    gachaState.phase = 'ascending';

                    // Step 3: Ascend
                    var ascendStart = performance.now();
                    var startGrabY = descendPixels;
                    // On fail: only ascend partway
                    var endGrabY = willFail ? descendPixels * (1 - FAIL_ASCEND_FRACTION) : ASCEND_TARGET;
                    var ascendDuration = willFail ? ASCEND_DURATION * FAIL_ASCEND_FRACTION : ASCEND_DURATION;

                    function animateAscend() {
                        var elapsed2 = performance.now() - ascendStart;
                        var t2 = Math.min(elapsed2 / ascendDuration, 1);
                        t2 = t2 < 0.5 ? 2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 2) / 2;
                        gachaState.grabY = startGrabY + (endGrabY - startGrabY) * t2;

                        if (elapsed2 < ascendDuration) {
                            requestAnimationFrame(animateAscend);
                        } else {
                            gachaState.grabY = endGrabY;

                            if (willFail) {
                                // === FAIL PATH: drop plush with rotation + bounce ===
                                gachaState.phase = 'dropping';
                                var plushKey = gachaState.hiddenPlush;
                                var plushL = GACHA_LAYERS[plushKey];
                                var fingersCenterX = 297 + gachaState.clawSlideX;
                                gachaState.dropPlush = plushKey;
                                gachaState.dropX = fingersCenterX - plushL.w / 2;
                                gachaState.dropY = GRAB_PLUSH_Y + gachaState.grabY;
                                gachaState.dropRotation = 0;
                                gachaState.dropIsFail = true;
                                gachaState.dropping = true;
                                gachaState.showGrab = false;
                                gachaState.hiddenPlush = null; // unhide from pile — drop sprite takes over
                                gachaState.clawY = 0;

                                // Target Y = original plush position in the pile
                                var originalY = GACHA_LAYERS[plushKey].y;
                                var dropStartY = gachaState.dropY;
                                var dropDistance = originalY - dropStartY;
                                var failDropStart = performance.now();

                                function animateFailDrop() {
                                    var elapsed3 = performance.now() - failDropStart;
                                    var t3 = Math.min(elapsed3 / FAIL_DROP_DURATION, 1);
                                    var bounceT = easeOutBounce(t3);
                                    gachaState.dropY = dropStartY + dropDistance * bounceT;
                                    gachaState.dropRotation = FAIL_ROTATION * (1 - Math.pow(1 - t3, 2));

                                    if (elapsed3 < FAIL_DROP_DURATION) {
                                        requestAnimationFrame(animateFailDrop);
                                    } else {
                                        gachaState.dropY = originalY;
                                        gachaState.dropRotation = FAIL_ROTATION;

                                        // Persist fallen plush and clear active drop
                                        gachaState.fallenPlushies.push({
                                            key: plushKey,
                                            x: gachaState.dropX,
                                            y: originalY,
                                            rotation: FAIL_ROTATION
                                        });
                                        gachaState.dropping = false;
                                        gachaState.dropPlush = null;
                                        gachaState.dropIsFail = false;

                                        setTimeout(function () {
                                            gachaState.phase = 'idle';
                                            gachaState.showGrab = false;
                                            gachaState.clawY = 0;
                                            gachaState.grabY = 0;
                                        }, 400);
                                    }
                                }
                                requestAnimationFrame(animateFailDrop);
                            } else {
                                // === SUCCESS PATH: slide to drop zone, then drop out ===
                                gachaState.phase = 'slideToDrop';
                                var successPlushKey = gachaState.hiddenPlush; // capture before any async
                                var slideStart = performance.now();
                                var slideFromX = gachaState.clawSlideX;
                                var slideToX = CLAW_OFFSETS.back;
                                // Set target NOW so main loop lerp doesn't fight the slide
                                gachaState.clawTargetX = slideToX;

                                function animateSlideToDrop() {
                                    var elapsed3 = performance.now() - slideStart;
                                    var t3 = Math.min(elapsed3 / SLIDE_TO_DROP_DURATION, 1);
                                    t3 = t3 < 0.5 ? 2 * t3 * t3 : 1 - Math.pow(-2 * t3 + 2, 2) / 2;
                                    gachaState.clawSlideX = slideFromX + (slideToX - slideFromX) * t3;
                                    if (elapsed3 < SLIDE_TO_DROP_DURATION) {
                                        requestAnimationFrame(animateSlideToDrop);
                                    } else {
                                        gachaState.clawSlideX = slideToX;
                                        gachaState.clawTargetX = slideToX;
                                        setTimeout(function () {
                                            startSuccessDrop(routeKey, successPlushKey);
                                        }, DROP_PAUSE);
                                    }
                                }

                                if (Math.abs(slideFromX - slideToX) < 1) {
                                    gachaState.clawSlideX = slideToX;
                                    setTimeout(function () {
                                        startSuccessDrop(routeKey, successPlushKey);
                                    }, DROP_PAUSE);
                                } else {
                                    requestAnimationFrame(animateSlideToDrop);
                                }
                            }
                        }
                    }
                    requestAnimationFrame(animateAscend);
                }, GRAB_PAUSE);
            }
        }
        requestAnimationFrame(animateDescend);
    }

    // ===== SIZING =====

    function sizeCanvas() {
        var canvas = gachaState.canvas;
        if (!canvas) return;

        var container = document.getElementById('gacha-fullscreen');
        var vh = container.clientHeight;

        // Snap display size to an exact integer multiple of the 500px art resolution.
        // This prevents sub-pixel interpolation that makes some lines thicker/thinner
        // or causes pixels to disappear at fractional scales (e.g. 1.2x).
        var dpr = window.devicePixelRatio || 1;
        // How many physical pixels per art pixel (round to nearest integer, minimum 1)
        var pixelScale = Math.max(1, Math.round(vh * dpr / 500));
        // The buffer is always an exact multiple of 500
        var bufferSize = 500 * pixelScale;
        // CSS display size = buffer / dpr → exact integer art pixels on screen
        var displaySize = bufferSize / dpr;

        canvas.style.width = displaySize + 'px';
        canvas.style.height = displaySize + 'px';
        canvas.width = bufferSize;
        canvas.height = bufferSize;

        gachaState.canvasScale = pixelScale;
        gachaState.ctx = canvas.getContext('2d');
        gachaState.ctx.imageSmoothingEnabled = false;
        gachaState.ctx.setTransform(pixelScale, 0, 0, pixelScale, 0, 0);

        if (gachaState.loaded) {
            renderGacha();
        }
    }

    // ===== INIT =====

    function initGacha() {
        var canvas = document.getElementById('gacha-canvas');
        gachaState.canvas = canvas;

        // Reset state
        gachaState.position = 0;
        gachaState.phase = 'idle';
        gachaState.blinkState = false;
        gachaState.blinkTimer = 0;
        gachaState.joystickDir = null;
        gachaState.buttonPressed = false;
        gachaState.clawY = 0;
        gachaState.grabY = 0;
        gachaState.showGrab = false;
        gachaState.hiddenPlush = null;
        gachaState.lastTime = performance.now();

        sizeCanvas();

        loadGachaImages(function () {
            renderGacha();
            gachaState.animFrame = requestAnimationFrame(gachaAnimLoop);
        });

        // Tap/click + drag/swipe handler
        if (!gachaState.clickBound) {
            gachaState.clickBound = true;

            // Drag state for joystick swipe detection
            var dragState = {
                active: false,
                startX: 0,
                startY: 0,
                startedOnJoystick: false,
                moved: false
            };
            var DRAG_THRESHOLD = 4; // pixels in logical coords — very sensitive

            function isAnimating() {
                return gachaState.phase === 'done' || gachaState.phase === 'fadeout' ||
                    gachaState.phase === 'grabbing' || gachaState.phase === 'descending' ||
                    gachaState.phase === 'grabbed' || gachaState.phase === 'ascending' ||
                    gachaState.phase === 'slideToDrop' || gachaState.phase === 'dropping' ||
                    gachaState.phase === 'complete';
            }

            function clientToLogical(clientX, clientY) {
                var rect = canvas.getBoundingClientRect();
                return {
                    x: (clientX - rect.left) * 500 / rect.width,
                    y: (clientY - rect.top) * 500 / rect.height
                };
            }

            function isOnJoystickArea(cx, cy) {
                // Broad joystick zone covering both left and right areas
                return hitTest(cx, cy, GACHA_HIT_AREAS.joyLeft) ||
                       hitTest(cx, cy, GACHA_HIT_AREAS.joyRight);
            }

            function handlePointerDown(clientX, clientY) {
                if (isAnimating()) return;
                var p = clientToLogical(clientX, clientY);
                dragState.active = true;
                dragState.startX = p.x;
                dragState.startY = p.y;
                dragState.moved = false;
                dragState.startedOnJoystick = isOnJoystickArea(p.x, p.y);
            }

            function handlePointerMove(clientX, clientY) {
                if (!dragState.active || !dragState.startedOnJoystick) return;
                if (isAnimating()) return;
                var p = clientToLogical(clientX, clientY);
                var dx = p.x - dragState.startX;

                if (!dragState.moved && Math.abs(dx) >= DRAG_THRESHOLD) {
                    dragState.moved = true;
                    if (dx < 0) {
                        moveJoystick('left');
                    } else {
                        moveJoystick('right');
                    }
                }
            }

            function handlePointerUp(clientX, clientY) {
                if (!dragState.active) return;
                var wasMoved = dragState.moved;
                var wasOnJoystick = dragState.startedOnJoystick;
                dragState.active = false;
                dragState.moved = false;

                // If dragged on joystick, the move already fired — skip tap
                if (wasMoved && wasOnJoystick) return;
                if (isAnimating()) return;

                // Fall back to tap behavior
                var p = clientToLogical(clientX, clientY);
                if (hitTest(p.x, p.y, GACHA_HIT_AREAS.joyLeft)) {
                    moveJoystick('left');
                } else if (hitTest(p.x, p.y, GACHA_HIT_AREAS.joyRight)) {
                    moveJoystick('right');
                } else if (hitTest(p.x, p.y, GACHA_HIT_AREAS.button)) {
                    pressButton();
                }
            }

            // Touch events
            canvas.addEventListener('touchstart', function (e) {
                e.preventDefault();
                e.stopPropagation();
                var t = e.touches[0];
                handlePointerDown(t.clientX, t.clientY);
            }, { passive: false });

            canvas.addEventListener('touchmove', function (e) {
                e.preventDefault();
                var t = e.touches[0];
                handlePointerMove(t.clientX, t.clientY);
            }, { passive: false });

            canvas.addEventListener('touchend', function (e) {
                e.preventDefault();
                var t = e.changedTouches[0];
                handlePointerUp(t.clientX, t.clientY);
            }, { passive: false });

            // Mouse events
            canvas.addEventListener('mousedown', function (e) {
                e.stopPropagation();
                handlePointerDown(e.clientX, e.clientY);
            });

            canvas.addEventListener('mousemove', function (e) {
                handlePointerMove(e.clientX, e.clientY);
            });

            canvas.addEventListener('mouseup', function (e) {
                handlePointerUp(e.clientX, e.clientY);
            });

            // Cancel drag if mouse leaves canvas
            canvas.addEventListener('mouseleave', function () {
                dragState.active = false;
                dragState.moved = false;
            });
        }

        // Resize handler
        window.addEventListener('resize', function () {
            sizeCanvas();
        });
    }

    // Start
    initGacha();
    </script>
</body>
</html>
